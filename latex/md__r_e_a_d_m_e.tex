\chapter{Arches}
\hypertarget{md__r_e_a_d_m_e}{}\label{md__r_e_a_d_m_e}\index{Arches@{Arches}}
\label{md__r_e_a_d_m_e_autotoc_md0}%
\Hypertarget{md__r_e_a_d_m_e_autotoc_md0}%
 Arches is a general-\/purpose and fast cycle-\/level hardware simulator.

The name is a pun on being able to simulate various architectures and on Arches National Park, Utah (it being traditional at the University of Utah to name software projects after Utah or Salt Lake City features).\hypertarget{md__r_e_a_d_m_e_autotoc_md1}{}\doxysection{\texorpdfstring{Setup (\+Simulator)}{Setup (Simulator)}}\label{md__r_e_a_d_m_e_autotoc_md1}
Visual Studio Components needed\+:
\begin{DoxyItemize}
\item Windows Universal CRT SDK
\begin{DoxyItemize}
\item Install using VS Installer
\end{DoxyItemize}
\item Windows 8.\+1 sdk
\begin{DoxyItemize}
\item Download from \href{https://go.microsoft.com/fwlink/p/?LinkId=323507}{\texttt{ https\+://go.\+microsoft.\+com/fwlink/p/?\+Link\+Id=323507}}
\end{DoxyItemize}
\item MSVC v142 -\/ VS 2020 C++ x64/x86 build tools (v14.\+16)
\begin{DoxyItemize}
\item Install via VS Installer; use the correct build tools for your environment ie. x64/x86
\end{DoxyItemize}
\end{DoxyItemize}

To build the simulator, simply open {\ttfamily arches.\+sln} in Visual Studio and batch build all.

The simulator itself will be built at {\ttfamily .build/\mbox{[}platform\mbox{]}/\mbox{[}config\mbox{]}/arches-\/sim.lib}, and any included samples using it will be built as executables in the same directory.

To run a sample, such as "{}sim-\/sample-\/mips"{}, simply select it in the solution explorer and run it.\hypertarget{md__r_e_a_d_m_e_autotoc_md2}{}\doxysection{\texorpdfstring{Setup (\+RISCV, Ubuntu Linux)}{Setup (RISCV, Ubuntu Linux)}}\label{md__r_e_a_d_m_e_autotoc_md2}
Testing programs on the framework requires the use of a RISC-\/V Cross-\/\+Compiler. Fortunately, many many people have devoted numerous hours to getting a decent RISC-\/V cross compiler implemented using GCC; this is available \href{https://github.com/riscv/riscv-gnu-toolchain}{\texttt{ here}}. For our own testing, these are the instructions we followed\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\$\ git\ clone\ https://github.com/riscv/riscv-\/gnu-\/toolchain}
\DoxyCodeLine{\$\ cd\ riscv-\/gnu-\/toolchain}
\DoxyCodeLine{\$\ git\ submodule\ update\ -\/-\/init\ -\/-\/recursive}
\DoxyCodeLine{\$\ sudo\ apt-\/get\ install\ autoconf\ automake\ autotools-\/dev\ curl\ python3\ libmpc-\/dev\ libmpfr-\/dev\ libgmp-\/dev\ gawk\ build-\/essential\ bison\ flex\ texinfo\ gperf\ libtool\ patchutils\ bc\ zlib1g-\/dev\ libexpat-\/dev}
\DoxyCodeLine{\$\ ./configure\ -\/-\/prefix=/opt/riscv\ -\/-\/with-\/arch=rv64imfa\ -\/-\/with-\/abi=lp64f}
\DoxyCodeLine{\$\ make\ -\/j\$(nproc)}
\DoxyCodeLine{\$\ echo\ -\/e\ "{}export\ PATH=\(\backslash\)"{}/opt/riscv/bin:\$PATH\(\backslash\)"{}"{}\ >>\ \string~/.bashrc}
\DoxyCodeLine{\$\ .\ \string~/.bashrc}

\end{DoxyCode}
 After these steps are completed, users are able to use {\ttfamily riscv64-\/uknown-\/elf-\/gcc} to compile C code and {\ttfamily riscv64-\/unknown-\/elf-\/g++} to compile C/\+C++ code.\hypertarget{md__r_e_a_d_m_e_autotoc_md3}{}\doxysection{\texorpdfstring{Adding custom instructions}{Adding custom instructions}}\label{md__r_e_a_d_m_e_autotoc_md3}
A key reason we used RISC-\/V over other research languages (i.\+e. MIPS) was the ease with which RISC-\/V can be extended. This allows researchers to use our framework to test novel hardware designs that may rely on custom instructions for drastic performance improvements. It\textquotesingle{}s important to note that this method allows progams using custom instructions to compile; however, it doesn\textquotesingle{}t act as a true cross-\/compiler, i.\+e. users will need to use inline ASM to include their custom instructions.

To add custom instructions, we followed the guide available \href{https://nitish2112.github.io/post/adding-instruction-riscv/}{\texttt{ here}}. Since the time of this guide\textquotesingle{}s writing, there have been a few notable changes to the build tree of the riscv-\/gnu-\/toolchain, so we will only note the differences below\+:
\begin{DoxyItemize}
\item Use {\ttfamily riscv-\/gnu-\/toolchain/riscv-\/binutils/include/opcode/riscv-\/opc.\+h} instead of {\ttfamily riscv-\/gnu-\/toolchain/riscv-\/binutils-\/gdb/include/opcode/riscv-\/opc.\+h}.
\item Similarly, use {\ttfamily riscv-\/gnu-\/toolchain/riscv-\/binutils/opcodes/riscv-\/opc.\+c} instead of {\ttfamily riscv-\/gnu-\/toolchain/riscv-\/binutils-\/gdb/opcodes/riscv-\/opc.\+c}. As the original guide notes, after the custom instruction has been added the toolchain will need to be rebuilt. This can be easily accomplished by running the following\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\$\ cd\ \{PATH/TO/RISCV\_GNU\_TOOLCHAIN\}}
\DoxyCodeLine{\$\ make\ clean}
\DoxyCodeLine{\$\ ./configure\ -\/-\/prefix=/opt/riscv\ -\/-\/with-\/arch=rv64g\ -\/-\/with-\/abi=lp64d}
\DoxyCodeLine{\$\ make\ -\/j\$(nproc)}

\end{DoxyCode}
 After rebuilding, the user should be able to run the cross-\/compiled programs with their custom instructions on the Arches framework, assuming they have extended the implementation of the RISC-\/V ISA provided by Arches to contain their custom instruction.
\end{DoxyItemize}

More details about the RISC-\/V ISA are available \href{https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMFDQC-and-Priv-v1.11/riscv-privileged-20190608.pdf}{\texttt{ by reading the specification}}, but it\textquotesingle{}s expected that users are at least familiar with RISC-\/V before they attempt to implement custom instructions.\hypertarget{md__r_e_a_d_m_e_autotoc_md4}{}\doxysection{\texorpdfstring{Contributing}{Contributing}}\label{md__r_e_a_d_m_e_autotoc_md4}
Follow the coding style in the existing code. Additionally, aim for cleanliness above all else. 